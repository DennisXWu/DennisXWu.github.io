---
title: 高性能MySQL学习（5）—创建高性能索引
date: 2021-1-22 23:29:53
categories:
- 数据库
tags:
- 数据库
---

# 高性能MySQL学习（5）—创建高性能索引

## 1、索引基础

### 1.1、什么是索引？

​      索引（在MySQL中也叫做“键（key）”）是**存储引擎用于快速找到记录的一种数据结构**。索引对于良好的性能非常关键。尤其是当表中的数据量越来越大时，索引对性能的影响愈发重要。在数据量较小且负载较低时，不恰当的索引对性能的影响可能还不明显，但当数据量逐渐增大时，性能则会急剧下降。 

### 1.2、索引的优缺点

- 优点：

> 1、索引大大减少了服务器需要扫描的数据量
>
> 2、索引可以帮助服务器避免排序和临时表
>
> 3、索引可以将随机I/O变成顺序I/O

- 缺点：

> 1、创建索引和维护索引要耗费时间，并且随着数据量的增加所耗费的时间也会增加
>
> 2、索引也需要占空间，如果我们有大量的索引，索引文件可能会比数据文件更快达到上线值
>
> 3、当对表中的数据进行增加、删除、修改时，索引也需要动态的维护，降低了数据的维护速度。

### 1.3、索引的类型？

​      索引有很多种类型，可以为不同的场景提供更好的性能。在MySQL中，**索引是在存储引擎层而不是服务器层实现的**。所以，并没有统一的索引标准：**不同存储引擎的索引的工作方式并不一样**，也不是所有的存储引擎都支持所有类型的索引。即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。 

- #### B-Tree索引

​     实际上很多存储引擎使用的是B+Tree，即**每一个叶子节点都包含指向下一个叶子节点的指针，从而方便叶子节点的范围遍历**。**底层的存储引擎也可能使用不同的存储结构**，例如，NDB集群存储引擎内部实际上使用了T-Tree结构存储这种索引，即使其名字是BTREE；InnoDB则使用的是B+Tree。
​     存储引擎以不同的方式使用B-Tree索引，性能也各有不同，各有优劣。例如，MyISAM使用前缀压缩技术使得索引更小，但**InnoDB则按照原数据格式进行存储**。再如MyISAM索引通过数据的物理位置引用被索引的行，而**InnoDB则根据主键引用被索引的行**。
​    **B-Tree通常意味着所有的值都是按照顺序存储的，并且每一个叶子页到根的距离相同**。图5-1展示了B-Tree索引的抽象表示。 

![]({{ site.url }}/assets/img/数据库/5.1.png)

​     **叶子节点比较特别，它们的指针指向的是被索引的数据**，**而不是其他节点页（不同引擎的“指针”类型不同）**。图5-1中仅绘制了**一个节点和其对应的叶子节点**，其实在根节点和叶子节点之间可能又很多层节点页。**树的深度和表的大小直接相关**。但是建议树的深度不要超过**4层**，即一般表大小不要大于**500w行**记录。 

​     **B-Tree 对索引列是顺序组织存储的，所以很适合查找范围数据**，所以mysql不适合用uuid作主键。例如，在一个基于文本域的索引树上，按字母顺序传递连续的值进行查找是非常合适的（这里与字符集和对应的排序集有关）。所以像“找出所有以I到K开头的名字”这样的查找效率会非常高。 

假设有如下的数据表：

```sql
CREATE TABLE PEOPLE(
    last_name varchar(50) not null,
    first_name varchar(50) not null,
    dob date not null,
    gender enum('m','f') not null,  -- 这个对应java中的什么类型可以试下。
    key(last_name,first_name,dob)
```

对于表中的每一行数据，索引中包含了last_name，first_name和dob列的值，图5-2显示了该索引是如何组织数据的存储的。

![]({{ site.url }}/assets/img/数据库/5.2.png)

​     请注意，索引对多个值进行排序的依据是CREAT TABLE语句中定义索引时列的顺序。看一下最后两个条目，两个人的姓和名都一样，则根据他们的出生日期来排列顺序。可以使用B-Tree索引的查询类型。**B-Tree索引适用于全键值、键值范围或键值前缀查找**。其中**键前缀查找只适用于根据最左前缀的查找**。前面所述的索引对如下类型的查询有效。

1. 全值匹配
   全值匹配指的是和索引中的**所有列进行匹配**。
2. 匹配最左前缀
   前面提到的索引可用于查找所有姓为Allen的人，即**只使用索引的第一列**。
3. 匹配列前缀
   例如前面提到的索引可用于查找姓在Allen和Barrymore之间的人。这里也只使用了索引的第一列。
4. 精确匹配某一列并范围匹配另外一列
   前面提到的索引页可以用于查找所有姓为Allen，并且名字是字母K开头的人。**即第一列last_name全匹配，第二列first_name范围匹配**。
5.  只访问索引的查询
   B-Tree通常可以支持“只访问索引的查询”,即查询**只需访问索引，而无须访问数据行**。后面我们将单独讨论这种“覆盖索引”的优化 。

 下面是一些关于B-Tree索引的限制：

1. 如果不是按照索引的**最左列**开始查找，则无法使用索引。
2. 不能**跳过索引**中的列。
3. 如果查询中有某个列的**范围查询**，则其**右边所有列都无法使用索引优化查找**。如有查询WHERE last_name=’Smith’ AND first_name LIKE ‘J%’ AND dob = ‘1976-12-23’，这个查询条件只能使用索引的前两列，因为这里LIKE是一个范围条件。在优化的时候，**可能需要使用相同的列但顺序不同的索引来满足不同类型的查询需求。**

- #### 哈希索引

哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效。在MySQL中，只有Memory引擎显示支持哈希索引。这也是Memory引擎表的默认索引类型，Memory引擎同时也支持B-Tree索引。
哈希索引有以下限制：

1. 哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。
2. 哈希索引数据并不是按照索引值顺序存储的，采用内存中随机桶的方式，所以也就无法用于排序。
3. 哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值得。例如，在数据列（A,B）上建立哈希索引，如果查询只有数据列A,则无法使用该索引。
4. 哈希索引只支持等值比较查询，包括=，IN()，。也不支持任何范围查找。
5. 访问哈希索引的数据非常快，除非有很多哈希冲突。当出现哈希冲突的时候，存储引擎必须遍历链表中所有的行指针，逐行进行比较，直到找到所有符合条件的行。
6. 如果哈希冲突很多的话，一些索引维护操作的代价也会很高。例如，如果在某个选择性很低（哈希冲突很多）的列上建立哈希索引，那么当从表中删除一行时，存储引擎需要遍历对应哈希值得链表中的每一行，找到并删除对应行的引用，冲突越多，代价越大。
   InnoDB引擎有一个特殊的功能叫做“自适应哈希索引”。当InnoDB注意到某些索引值被使用得非常频繁时，它会在内存中基于B-Tree索引之上再创建一个哈希索引，这样就让B-Tree索引也具有哈希索引的一些优点，比如快速的哈希查找。这是一个完全自动的、内部的行为，用户无法控制或者配置，不过如果有必要，完全可以关闭该功能。
   有时可以自己用单独一个列保存另外一个列的哈希值，但建议用CRC32()或者MD5()函数返回值的一部分来作为自定义哈希函数。不要使用SHA1()和MD5()作为哈希函数。因为这两个函数计算出来的哈希值时非常长的字符串，会浪费大量空间，比较时也会更慢。

 处理哈希冲突。当使用哈希索引进行查询的时候，必须在WHERE子句中包含常量值。 

- #### 空间数据索引

​     MyISAM表支持空间索引，可以用作地理数据存储。和B-Tree索引不同，这类索引无须前缀查询。空间索引会从所有维度来索引数据。查询时，可以有效地使用任何维度来组合查询。必须使用MySQL的GIS相关函数如MBRCONTAINS()等来维护数据。MySQL的GIS支持不完善。建议用开源关系数据库系统中对GIS的解决方案做的比较好的PostgreSQL的PostGIS。

- #### 全文检索

全文索引是一种特殊的类型的索引，它查找的是文本中的关键词，而不是直接比较索引中的值。它有许多需要注意的细节。如停用词、词干和复数、布尔搜索等。全文索引更类似于搜索引擎做的事情，而不是简单的WHERE条件匹配。在相同的列上同时创建全文索引和基于值得B-Tree索引不会有冲突，全文索引适用于MATCH AGAINST操作，而不是普通的WHERE条件操作。

- #### 其他索引类别

TokuDB使用分形树索引，这是一类较新开发的数据结构，既有B-Tree的很多优点，也避免了B-Tree的一些缺点。如果通读完本章，可以看到很多关于InnoDB的主题，包括聚簇索引，覆盖索引等。多数情况下，针对InnoDB的讨论也都适用于TokuDB。

## 2、高性能的索引策略

### 2.1、独立的列

​    如果查询中的列不是独立的，则MySQL就不会使用索引。“独立的列”是指索引列不能是表达式的一部分，也不能是函数的参数。

```mysql
如:SELECT actor_id FROM actor WHERE actor_id + 1 = 5; 
```

### 2.2、前缀索引和索引选择性

​     有时候需要索引很长的字符串，这样让索引变得大且慢。通常可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。但这样会降低索引的选择性。一般情况下某个列前缀的选择性也是足够高的，足以满足查询性能。对于BLOG、TEXT或者很长的VARCHAR类型的列，必须使用前缀索引，因为MySQL不允许索引这些列的完整长度。诀窍在于要选择足够长的前缀以保证较高的选择性，同时又不能太长（以便节约空间）。**前缀应该足够长，以使得前缀索引的选择性接近于索引整个列**。换句话说，前缀的“基数”应该接近于完整列的“基数”。 

### 2.3、 多列索引

集中精力优化索引的顺序。

### 2.4、选择合适的索引列顺序

   在一个多列B-Tree索引中，索引列的顺序意味着**索引首先按照最左列进行排序**，其次是第二列，等等。所以，索引可以按照升序或者降序进行扫描，以满足精确符合列顺序的ORDER BY、GROUP BY和DISTINCT等子句的查询需求。对于如何选择索引的列顺序有一个经验法则：**将选择性最高的列放到索引最前列**，但通常不如避免随机IO和排序那么重要。我们知道有时排序需要占用很多时间。**当不需要考虑排序和分组时，将选择性最高的列放在前面通常是很好的**。这时候索引的作用只是用于优化WHERE条件的查找。然而，性能不只是依赖于所有索引列的选择性（整体基数），也和查询条件的具体值有关，也就是和值得分布有关。可能需要根据那些运行频率最高的查询来调整索引列的顺序，让这种情况下索引的选择性最高。

以下面的查询为例：

```mysql
SELECT * FROM payment WHERE staff_id = 2 AND customer_id = 584;
```

是应该创建一个（staff_id,customer_id)索引还是应该颠倒一下顺序？可以跑一些查询来确定在这个表中值得分布情况，并且确定哪个列的选择性更高。先用下面的查询预测一下。看看各个WHERE条件的分支对应的数据基数有多大：

![在这里插入图片描述]({{ site.url }}/assets/img/数据库/5.3.png)
根据前面的经验法则：应该将索引列customer_id放到前面，因为对应条件值的customer_id数量更小。我们再来看看对于这个customer_id的条件值，对应的staff_id列的选择性如何：
![在这里插入图片描述]({{ site.url }}/assets/img/数据库/5.4.png)
这样做有一个地方需要注意，查询的结果非常依赖于选定的具体值。如果按上述办法优化，可能对其他一些条件值得查询不公平，服务器的整体性能可能变得更糟，或者其他某些查询的运行变得不如预期。

这样做有一个地方需要注意，查询的结果非常依赖于选定的具体值。如果按上述办法优化，可能对其他一些条件值得查询不公平，服务器的整体性能可能变得更糟，或者其他某些查询的运行变得不如预期。

如果是从诸如pt-query-digest这样的工具的报告中提取“最差”查询，那么再按上述办法选定的索引顺序往往是非常高效的。如果没有类似的具体查询来运行，那么最好还是按经验法则来做，因为经验法则则考虑的是全局基数和选择性，而不是某个具体查询：
![在这里插入图片描述]({{ site.url }}/assets/img/数据库/5.5.png)
customer_id的选择性更高，所以答案是将其作为索引列的第一列：

```mysql
ALTER TABLE payment A
DD KEY(customer_id, staff_id);
```

### 2.5、聚簇索引

​    聚簇索引**不是单独的索引类型，而是一种数据存储方式**。InnoDB的聚簇索引实际上在同一个结构中**保存了B-Tree索引**和**数据行**。
当表有聚簇索引时，它的**数据行实际上存放在索引的叶子页中**。术语“聚簇”表示数据行和相邻的键值紧凑地存在一起。InnoDB将通过主键聚集数据，这也就是说图5-3中的“被索引的列”就是主键列。如果没有定义主键，InnoDB会选择一个唯一的非空索引代替。如果没有这样的索引，InnoDB会隐式定义一个主键来作为聚簇索引。InnoDB只聚集在同一个页面中的记录。包含相邻键值得页面可能会相距甚远。所以，聚簇主键可能对性能有帮助，但也可能导致严重的性能问题。 

![]({{ site.url }}/assets/img/数据库/5.6.png)

聚集的数据有一些重要的优点：

1. 可以把相关数据保存在一起。例如实现电子邮箱时，可以根据用户ID来聚集数据，这样只需要从磁盘读取少数的数据页就能获取某个用户的全部邮件。如果没有使用聚簇索引，则每封邮件可能导致一次磁盘I/O。
2. 数据访问更快。聚簇索引将索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取数据通常比在非聚簇索引中查找要快。
3. 使用覆盖索引扫描的查询可以直接使用页节点中的主键值。

如果在设计表和查询时能充分利用上面的优点，那就能极大地提升性能。同时，聚簇索引也有一些缺点：

1. 聚簇数据最大限度地提高了I/O密集型应用的性能，但如果数据全部都放在内存中，则访问顺序就没有那么重要，聚簇索引则没啥优势。这是充分利用了不同的存储介质。
2. 插入速度严重依赖于插入顺序。按照主键的顺序插入是加载数据到InnoDB表中速度最快的方式。但如果不是按照主键顺序加载数据，那么在加载完成后最好使用OPTIMIZE TABLE命令重新组织一下表。
3. 更新聚簇索引的代价很高，因为会强制InnoDB将每个被更新的行移动到新的位置。
4.  基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临"页分裂”的问题。当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将给页分裂成两页来容纳该行，这就是页分裂。页分裂会导致表占用更多的磁盘空间。
5.  聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候。
6.  二级索引（非聚簇索引）可能比想象的要更大，因为在二级索引的叶子节点包含了引用行的主键列。

### 2.6、覆盖索引

通常大家都会根据查询的WHERE条件来创建合适的索引，不过这只是索引优化的一个方面。设计优秀的索引应该考虑到整个查询，而不单单是WHERE条件的部分。**如果索引的叶子节点中已经包含要查询的数据，那么就没有必要回查表**。如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称为覆盖索引。
覆盖索引是非常有用的工具，能够极大地提高性能。考虑一下如果查询只需要扫描索引而无须回表，会带来以下好处：

1. 索引条目通常远小于数据行大小，所以如果只需要读取索引，那MySQL就会极大地减少数据访问量。这对缓存的负载非常重要，因为这种情况下响应时间大部分花费在数据拷贝上。覆盖索引对于I/O密集型的应用也有帮助，因为索引比数据更小，更容易全部放在内存中。
2. 因为索引是按照列值顺序存储的（至少在单个页内是如此），所以对于I/O密集型的范围查询会比随机从磁盘读取每一行数据的I/O要少很多。
3. 一些存储引擎如MyISAM在内存中只缓存索引，数据则依赖于操作系统来缓存，因此要访问数据需要一次系统调用。
4. 由于InnoDB的聚簇索引，覆盖索引对InnoDB表特别有用。**InnoDB的二级索引在叶子节点中保存了行的主键值**，所以如果二级主键能够覆盖查询，则可避免对主键索引的二次查询。不是所有类型的索引都可以成为覆盖索引。**覆盖索引必须要存储列的值**，而哈希索引、空间索引和全文索引等都不存在索引列的值，所以MySQL只能使用B-Tree索引做覆盖索引。

### 2.7、 使用索引扫描来做排序

​       MySQL有两种方式可以生成有序的结果：（1）通过排序操作；（2）或者按索引顺序扫描；如果EXPLAIN 出来的type列的值为“index”。则说明MySQL出来的type列的值为“index”，则说明MySQL使用了索引扫描来做排序。如果索引不能覆盖查询所需的全部列，那就不得不每扫描一条索引记录就都回表查询一次对应的行。这基本上都是随机I/O，因此按索引顺序读取数据的速度通常要比顺序地全表扫描慢，尤其是在I/O密集型的工作负载时。
​MySQL可以使用同一个索引既满足排序，又用于查找行。因此，如果可能，设计索引时应该尽可能地同时满足这两种任务。只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向（倒序或正序）都一样时，MySQL才能够使用索引来对结果做排序。如果查询需要关联多张表，则只有当ORDER BY子句引用的字段全部为第一个表时，才能使用索引做排序。ORDER BY子句和查找型查询的限制是一样的：需要满足索引的最左前缀的要求；否则MySQL都需要执行排序操作，而无法利用索引排序。

有一种情况下ORDERY BY子句可以不满足索引的最左前缀的要求， 就是前导列为常量的时候，如果WHERE子句或者JOIN子句中对这些列指定了常量，就可以“弥补”索引的不足。

### 2.8、冗余索引带来的性能问题

​     MySQL允许在**相同列上创建多个索引**。重复索引是指在相同的列上按照相同的顺序创建相同类型的索引。应该**避免这样创建重复索引**，发现以后也应该立即移除。

 有时会在不经意间创建了重复索引，例如下面的代码： 

```mysql
CREATE TABLE test (
ID INT NOT NULL PRIMARY KEY,
A INT NOT NULL,
B INT NOT NULL,
UNIQUE(ID),
INDEX(ID)
) ENGINE=InnoDB;
```

   上面的写法其实创建了三个重复的索引，事实上，MySQL的唯一限制和主键限制都是通过索引实现的。

   冗余索引和重复索引有一些不同。如果创建了索引（A，B），再创建索引（A）就是冗余索引。因为这只是前一个索引的前缀索引。还有一种情况是将一个索引扩展为（A，ID），其中ID是主键，对于InnoDB来说主键列已经包含在二级索引中了，所以这也是冗余的。但有时出于性能方面的考虑需要冗余索引，因为扩展已有的索引会导致其变得太大，从而影响其他使用该索引的查询的性能。例如，如果在整数列上游一个索引，现在需要额外增加一个很长的VARCHAR列来扩展该索引，那性能可能会急剧下降。

### 2.9、未使用的索引

有一些完全没有使用的索引，建议删除。有两个工具可以帮助定位未使用的索引。最简单有效的办法是在Percana Server或者MariaDB中先打开userstates服务器变量（默认是关闭的），然后让服务器正常运行一段时间，再通过查询INFORMATION_SCHEMA.STATISTICS就能查询到每个索引的使用频率。

### 2.10、索引和锁

索引可以让查询锁定更少的行。如果你的查询从不访问那些不需要的行，那么就会锁定更少的行，从两个方面来看这对性能都有好处。

但是MySQL有时会使用间隙锁锁住不需要的数据。如果不能使用索引查找和锁定行的话就可能会更糟糕。MySQL会做全表扫描并锁住所有的行。
关于InnoDB、索引和锁有一些很少有人知道的细节：InnoDB在二级索引上使用共享（读）锁，但访问主键索引需要排他（写）锁。这消除了使用覆盖索引的可能性，并且使得SELECT FOR UPDATE 比 LOCK IN SHARE MODE或非锁定查询要慢很多。

## 3、索引案例

如果MySQL使用某个索引进行范围查询，也就无法再使用另一个索引（或者是该索引的后续字段）进行排序了。

### 3.1 、支持多种过滤条件

​    现在需要看看哪些列拥有很多不同的取值，哪些列在WHERE子句中出现得最频繁。在有更多不同值的列上创建索引的选择性会更好。一般来说这样做是对的，因为可以让MySQL更有效地过滤掉不需要的行。
​country列的选择性不高，但可能很多查询都会用到。sex列的选择性肯定很低，但也会在很多查询中用到。所以考虑到使用的频率，还是建议在创建不同组合索引的时候将（sex, country）列作为前缀。

### 3.2、避免多个范围条件

   在这个案例中，优化器的特性是影响索引策略的一个很重要的因素。如果未来版本的MySQL能够实现松散索引扫描，就能在一个索引上使用多个范围条件，那也就不需要为上面考虑的这类查询使用IN()列表了。

### 3.3、优化排序

我们经常会遇到在翻页时，越往后面的分页，MySQL需要花费大量的时间来扫描丢弃的数据，需要的成本就越高。

## 4、参考资料

https://blog.csdn.net/gonghaiyu/article/details/107805165

